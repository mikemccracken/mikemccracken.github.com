<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>michael-mccracken.net (grad-school)</title><link>http://michael-mccracken.net/</link><description></description><language>en</language><lastBuildDate>Fri, 27 Jun 2014 12:24:48 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Announcing Skim: Stop printing - Start Skimming.</title><link>http://michael-mccracken.net/2007/04/announcing-skim-stop-printing-start-skimming/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;If you spend a lot of time reading articles and research papers that you get in PDF form, then you might be interested in the latest app from the folks who brought you &lt;a href="http://bibdesk.sf.net"&gt;BibDesk&lt;/a&gt;. If you already use BibDesk, then you certainly want to take a look.&lt;/p&gt;
&lt;p&gt;Even though we keep our research papers stored on disk as PDF, all too often we print them out to read and write notes on. There's something missing in the experience of reading papers on a computer, but it doesn't have to be that way.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://skim-app.sourceforge.net/images/skimIcon.png"&gt;&lt;/p&gt;
&lt;p&gt;Announcing &lt;a href="http://skim-app.sf.net"&gt;Skim&lt;/a&gt;. Skim is a PDF reading and note-taking app for Mac OS X that is designed to make reading research papers and manuals better. Just like in Preview, you can search, scan, and zoom through PDFs, but you also get some custom features for your workflow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Snapshots: if there's a graph on page two and the description continues to page three, just draw a box around the graph with the command key down and a snapshot window pops up with the graph, and you can keep on reading with the graph in view. For more fun, minimize that snapshot window - they stick around in their own dock in the document window.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://michael-mccracken.net/2007/skimSnapshot.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tooltips: If a PDF has links, such as for citation references or indexes and section headings, you can click on them as usual to go to the destination, but there's more - hover the mouse over those links and Skim will show you a tooltip with the target of the link. No more losing your place to peek at a citation! For more fun, command-click on a link to pop up a snapshot window showing the link's destination.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://michael-mccracken.net/2007/skimTooltip.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Presentation and Full-screen Modes: Full-screen reading is handy. So is showing a PDF as a presentation. But they're a little different. For instance, you might not want to show the table of contents in a presentation, but it's nice to see it when you're just reading by yourself. So Full-screen and Presentation are separate modes in Skim.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There's plenty more - &lt;a href="http://skim-app.sf.net"&gt;download it&lt;/a&gt; and take a look, and join the &lt;a href="http://skim-app.sf.net/mailingLists.html"&gt;mailing list&lt;/a&gt; to discuss it. There's even a full help book in the first public beta release!&lt;/p&gt;
&lt;p&gt;Many thanks to everyone who has worked on this app, and especially to Christiaan Hofman, who moved the app from a prototype to something really useful faster than I would have thought possible.&lt;/p&gt;</description><category>grad-school</category><category>mac</category><category>research</category><category>skim</category><guid>http://michael-mccracken.net/2007/04/announcing-skim-stop-printing-start-skimming/</guid><pubDate>Mon, 02 Apr 2007 18:12:00 GMT</pubDate></item><item><title>Tomorrow's Professor Blog</title><link>http://michael-mccracken.net/2006/03/tomorrows-professor-blog/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;The &lt;a href="http://ctl.stanford.edu/Tomprof/index.shtml"&gt;Tomorrow's Professor Mailing List&lt;/a&gt;, a great resource for tips and info about what professors actually do (as opposed to what you learn in grad school), is now out in a weblog form, in case you'd rather read in an aggregator than a mail client: &lt;a href="http://amps-tools.mit.edu/tomprofblog/"&gt;Tomorrow's Professor Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'd recommend poking through the back issues - there's a lot of wisdom in there.&lt;/p&gt;</description><category>grad-school</category><guid>http://michael-mccracken.net/2006/03/tomorrows-professor-blog/</guid><pubDate>Wed, 08 Mar 2006 02:13:00 GMT</pubDate></item><item><title>Introducing LENS</title><link>http://michael-mccracken.net/2006/02/introducing-lens/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;I've just put up the website for my current project (to be part of my Ph.D. dissertation work): &lt;a href="http://www.cse.ucsd.edu/~mmccrack/lens/"&gt;LENS&lt;/a&gt;, a framework for program information manipulation that presents a uniform interface to selective user and automated queries about many types of program metrics, including success and diagnostic information about compiler optimizations and code generation.&lt;/p&gt;
&lt;p&gt;I'm not sure how many readers of my weblog will be interested, but there's a link to a technical report on there if you want the gory details.&lt;/p&gt;
&lt;p&gt;Feedback and questions are very welcome - the more opportunities I get to explain what I'm doing, the better I get at it.&lt;/p&gt;</description><category>HPC</category><category>compilers</category><category>grad-school</category><category>me</category><category>research</category><guid>http://michael-mccracken.net/2006/02/introducing-lens/</guid><pubDate>Wed, 15 Feb 2006 04:29:00 GMT</pubDate></item><item><title>Jorge Cham and "The Power of Procrastination"</title><link>http://michael-mccracken.net/2006/02/jorge-cham-and-the-power-of-procrastination/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;Just went to see Jorge Cham's talk &lt;a href="http://www.phdcomics.com/speaking.htm"&gt;"The Power of Procrastination"&lt;/a&gt; about grad school.
There were plenty of good grad-school jokes and a general feeling of relief that comes with being in a big room full of people who laugh at the same old chestnuts about how nobody ever really feels like they fit in and always feel guilty about whatever it is you spend your free time doing - you know, when you &lt;em&gt;should&lt;/em&gt; be doing research!&lt;/p&gt;
&lt;p&gt;If you get a chance to see his talk, go for it, even if you've read all the comics, it'll make you feel better. And if you haven't seen the comics, go &lt;a href="http://www.phdcomics.com/comics/comics.php"&gt;read them all first&lt;/a&gt;, then see the talk. Now I'm going to get back to work.&lt;/p&gt;</description><category>grad-school</category><guid>http://michael-mccracken.net/2006/02/jorge-cham-and-the-power-of-procrastination/</guid><pubDate>Thu, 09 Feb 2006 05:26:00 GMT</pubDate></item><item><title>What's hot in CS</title><link>http://michael-mccracken.net/2006/02/whats-hot-in-cs/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;Today, a group of graduating PhD students in our department met up to brief each other on what's new and hot in their respective fields, to remind each other of what's going on outside their respective specialties. The idea is that when interviewing for jobs, you have to hold up your end of a conversation with professors outside your specialty, and it helps to know a bit about their field.&lt;/p&gt;
&lt;p&gt;To quote one professor in our department, "...there is a special circle
of hell reserved for grad students interviewing for jobs who are unable to
answer questions of the form, 'Oh, you're from UCSD.  What's Professor
so-and-so up to these days?'."&lt;/p&gt;
&lt;p&gt;It took about six hours to get through talks from students working on Architecture, Bioinformatics, Systems, Graphics, Vision, Databases, Security, VLSI and more, and I'm not going to try to repeat any of the details, because frankly I'm numb. I will say that it was a great idea, and if you're a grad student and your department doesn't do something like this, you should start a tradition.&lt;/p&gt;
&lt;p&gt;I will mention one thing: automatic detection and adaptation to network attacks is &lt;a href="http://www.jacobsschool.ucsd.edu/news_events/releases/release.sfe?id=400"&gt;so hot right now&lt;/a&gt;.&lt;/p&gt;</description><category>grad-school</category><category>research</category><guid>http://michael-mccracken.net/2006/02/whats-hot-in-cs/</guid><pubDate>Sun, 05 Feb 2006 09:02:00 GMT</pubDate></item><item><title>Talk: Bart Miller and Dyninst</title><link>http://michael-mccracken.net/2006/02/talk-bart-miller-and-dyninst/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;In a recent largescale systems seminar*, we had &lt;a href="http://www.cs.wisc.edu/~bart/"&gt;Bart Miller&lt;/a&gt; from &lt;a href="http://www.cs.wisc.edu/"&gt;Wisconsin&lt;/a&gt; talk about some of the upcoming work on &lt;a href="http://www.dyninst.org"&gt;DynInst&lt;/a&gt;. DynInst is an API for runtime code patching, which lets you do things like attach to a running program and insert your own code around every network call, or replace procedures with your own versions. You can even do something as insane as calling a function every time the instrumented program accesses memory. (We do roughly that here at &lt;a href="http://www.sdsc.edu/PMaC/"&gt;PMaC&lt;/a&gt; with &lt;a href="http://www.sdsc.edu/PMaC/MetaSim/metasim.html"&gt;MetaSim&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;Bart talked about some of the challenges they've had to face with DynInst and the directions they're planning to take it in the future. The major news is that they're planning to improve support for binary rewriting, in which you use the same interface to instrument an object file and produce a new executable instead of just doing it in memory. Also, they are planning on breaking it up into a few smaller libraries so you don't have to link everything in if you're building a tool that doesn't need all of DynInst. These are both good news for users.&lt;/p&gt;
&lt;p&gt;He discussed some interesting applications of DynInst (such as trapping and removing calls to license checking code), and some odd situations that have driven development, like users who needed to instrument binaries that were hundreds of megabytes large (not with linked libraries, just the one file). He also highlighted some cases where DynInst really shines, such as needing to instrument a program that you can't even relink, due to lack of source code access or simple overwhelming makefile confusion. The facility for removing instrumentation led to a clever code coverage tool that removed instrumentation on a block after the block was touched once, leading to a really impressive speedup.&lt;/p&gt;
&lt;p&gt;They've also used it to observe viruses without allowing them to write to disk, including nifty tricks like waiting until the virus uncompresses itself, then saving the uncompressed virus for later analysis. The extensive work they've done on binary analysis is important here, because viruses don't really come with symbol tables for handy debugging.&lt;/p&gt;
&lt;p&gt;I thought that the most interesting part of the talk was about the challenges they've addressed through the course of the project. For instance, it is surprising how often with production compilers, that the symbol tables contain entries which are totally bogus. An example he used was that the function size information in most symbol tables is never right. Few tools pay attention to this, so it goes unfixed. One reason for this inaccuracy is another reason to consider using DynInst or something like it to build program analysis tools - object code layout is getting pretty confusing, and they've done the hard work of analysis already. For instance, noncontiguous functions are common. Apparently that's rampant in Microsoft's products, due to optimizations that reorder hot basic-blocks. Other weird code arrangements are common, including functions sharing object code. Compilers sometimes appear to be active adversaries to program analysis tools, and many tools in common use are making assumptions about code layout that are increasingly less likely to be correct.&lt;/p&gt;
&lt;p&gt;I asked how symbol table information needs to be improved to let tools keep up, and what more information one needs to get from the compiler, and his response was that expecting many-to-many relationships for mapping code to source is very important if your tools need to deal with real code.&lt;/p&gt;
&lt;p&gt;Thanks to Bart Miller for the talk - any errors above are mine, the ideas and hard work described are all theirs!&lt;/p&gt;
&lt;p&gt;*I had wanted to post about it right away, but I didn't get to it until two weeks later.&lt;/p&gt;</description><category>grad-school</category><category>programming</category><category>research</category><guid>http://michael-mccracken.net/2006/02/talk-bart-miller-and-dyninst/</guid><pubDate>Fri, 03 Feb 2006 23:33:00 GMT</pubDate></item><item><title>State of the Union</title><link>http://michael-mccracken.net/2006/02/state-of-the-union/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;I completely missed this year's State of the Union address, but was pleased to see this quote from the speech:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;First, I propose to double the federal commitment to the most critical basic research programs in the physical sciences over the next 10 years. This funding will support the work of America's most creative minds as they explore promising areas such as nanotechnology, supercomputing, and alternative energy sources.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Having supercomputing named specifically by the President ought to be a nice thing to be able to point to when selling our field. It happens less and less these days, but I've definitely had people ask me if supercomputing was a dead field - the answer is a resounding no, and this just adds to the list of indicators, including the DARPA &lt;a href="http://www.darpa.mil/ipto/programs/hpcs/"&gt;HPCS&lt;/a&gt; program.&lt;/p&gt;</description><category>HPC</category><category>grad-school</category><category>research</category><guid>http://michael-mccracken.net/2006/02/state-of-the-union/</guid><pubDate>Wed, 01 Feb 2006 12:53:00 GMT</pubDate></item><item><title>PLDI Papers I'm interested in, part one</title><link>http://michael-mccracken.net/2006/01/pldi-papers-im-interested-in-part-one/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;I mentioned that I'd post about some of the papers I found interesting from this year's PLDI conference. Disclaimer: for the most part this is based on reading the abstracts only, so this shouldn't be considered a thorough review.&lt;/p&gt;
&lt;p&gt;Session one is Transactions. I will probably look through these, especially the first paper, &lt;em&gt;"The Atomos Transactional Programming Language"&lt;/em&gt; [1] from Stanford, because transactional memory and processing seems to be a consensus pick for the next big thing, and &lt;a href="http://www.computerhistory.org/events/lectures/smith_01232001/"&gt;Burton Smith&lt;/a&gt; once told me that languages using transactional memory and invariants with respect to state are his bet for what can solve the parallel programming problem. (What problem? It's too hard to write good parallel code.) So, I want to see what a transactional language looks like.&lt;/p&gt;
&lt;p&gt;There's a paper in the Compilers session that looks like a cool idea for improving analysis - &lt;em&gt;"A Framework for Unrestricted Whole-Program Optimization"&lt;/em&gt; [2]. The &lt;a href="http://liberty.princeton.edu/Publications/index.php?abs=1&amp;amp;setselect;=pldi06_pbe"&gt;abstract&lt;/a&gt; says they have a way for intra-procedural passes to work on arbitrary subgraphs of the program, so they're not just limited by procedural boundaries, and don't have to rely on inlining to optimize across calls. I'm curious what languages it supports, and how the scheme would work with dynamic languages.&lt;/p&gt;
&lt;p&gt;A paper about dynamic software updating, &lt;em&gt;"Practical Dynamic Software updating for C"&lt;/em&gt; [3] (&lt;a href="http://www.cs.umd.edu/projects/dsu/"&gt;project link&lt;/a&gt;) is also interesting, because it seems like a step towards the way things should work. Essentially, they compile a program so that it can be easily updated without stopping it. They do it in a way that doesn't violate type-safety and sounds reasonably efficient. It reminds me of Apple's ZeroLink and Fix &amp;amp; Continue (note that those aren't the first examples of such technology), and I'm curious how similar it is. Certainly I don't think Fix &amp;amp; Continue tries to guarantee type-safety.&lt;/p&gt;
&lt;p&gt;The parallelism session should be interesting, and I'm most curious to see an abstract for &lt;em&gt;"Shared Memory Programming for Large Scale Machines"&lt;/em&gt; [4], I can't tell from the title if they are introducing a new language or measuring an existing technique. I have a note to myself somewhere to look for a full copy of that paper.&lt;/p&gt;
&lt;p&gt;Power has been a big deal in HPC and mobile devices for a while, and now it's everyone's problem, so &lt;em&gt;"Reducing NoC Energy Consumption Through Compiler-Directed Channel Voltage Scaling"&lt;/em&gt; [5] caught my eye. I'm always interested to learn about power usage effects of different kinds of code, since I have found it to be satisfyingly unintuitive at times. (Maybe I should've taken more EE classes!) Also, this is a paper from Penn State, and I'm curious what research they've got going on back at my alma mater.&lt;/p&gt;
&lt;p&gt;I'll probably read everything in the Runtime Optimization and Profiling session, but &lt;em&gt;"Online Performance Auditing: Using Hot Optimizations Without Getting Burned"&lt;/em&gt; [6] is particularly interesting, since I know Brad Calder and his students do really good work, and I honestly didn't know what Jeremy was up to. I should probably be more social around the department. (These guys are at UCSD)&lt;/p&gt;
&lt;p&gt;OK, I'm not out of interesting papers, but I'm going to stop here for now. Check out the program, let me know what you think is cool - am I missing something really great?&lt;/p&gt;
&lt;h5&gt;References&lt;/h5&gt;
&lt;p&gt;[1] "The Atomos Transactional Programming Language"
Brian D. Carlstrom, JaeWoong Chung, Austen McDonald, Hassan Chafi,
Christos Kozyrakis and Kunle Olukotun.&lt;/p&gt;
&lt;p&gt;[2] "A Framework for Unrestricted Whole-Program Optimization"
Spyridon Triantafyllis, Matthew J. Bridges, Easwaran Raman, Guilherme Ottoni, and David I. August&lt;/p&gt;
&lt;p&gt;[3] "Practical Dynamic Software Updating for C"
Iulian Neamtiu, Michael Hicks, Gareth Stoyle and Manuel Oriol&lt;/p&gt;
&lt;p&gt;[4] "Shared Memory Programming for Large Scale Machines"
Christopher Barton, Calin Cascaval, Siddhartha Chatterjee, George Almasi, Yili Zheng, Montse Farreras, Jose Amaral&lt;/p&gt;
&lt;p&gt;[5] "Reducing NoC Energy Consumption Through Compiler-Directed Channel Voltage Scaling"
Guangyu Chen, Feihui Li, Mahmut Kandemir, Mary Irwin&lt;/p&gt;
&lt;p&gt;[6] "Online Performance Auditing: Using Hot Optimizations Without Getting Burned"
Jeremy Lau, Matthew Arnold, Michael Hind, Brad Calder&lt;/p&gt;</description><category>compilers</category><category>grad-school</category><category>research</category><guid>http://michael-mccracken.net/2006/01/pldi-papers-im-interested-in-part-one/</guid><pubDate>Fri, 27 Jan 2006 01:39:00 GMT</pubDate></item><item><title>PLDI 2006 Papers</title><link>http://michael-mccracken.net/2006/01/pldi-2006-papers/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;The &lt;a href="http://research.microsoft.com/conferences/pldi06/Sessions.htm"&gt;technical program&lt;/a&gt; for PLDI 2006 is out now - there are certainly a lot of interesting papers in there. I'm looking through them now and will probably comment on a few of the ones I think are cool in another post.&lt;/p&gt;
&lt;p&gt;PLDI is traditionally a very competitive conference with an emphasis on experimental results, and this year they received 169 submissions and accepted 36. PLDI stands for "Programming Language Design and Implementation", and covers compilers, languages and runtime systems.&lt;/p&gt;
&lt;p&gt;There are some interesting workshops co-located with PLDI this year:
 a Workshop on Transactional Memory Workloads (&lt;a href="http://odin.cs.uiuc.edu/WTW/"&gt;WTW&lt;/a&gt;), a Workshop on Programming Languages and Analysis for Security (&lt;a href="http://www.cis.upenn.edu/~stevez/plas/plas06.html"&gt;PLAS&lt;/a&gt;), and
 the first ACM SIGPLAN Workshop on Languages, Compilers, and Hardware Support for Transactional Computing (&lt;a href="http://www.cs.purdue.edu/homes/jv/events/TRANSACT/"&gt;TRANSACT&lt;/a&gt;). Does it sound like transactional computing is hot these days? Yes it does...&lt;/p&gt;
&lt;p&gt;Update: for historical reference, this year's 21% acceptance rate puts it right at the average, according to the ACM's data from 1995-2003.&lt;/p&gt;</description><category>HPC</category><category>compilers</category><category>grad-school</category><category>research</category><guid>http://michael-mccracken.net/2006/01/pldi-2006-papers/</guid><pubDate>Tue, 24 Jan 2006 02:46:00 GMT</pubDate></item><item><title>On Reviewing</title><link>http://michael-mccracken.net/2006/01/on-reviewing/</link><dc:creator>Michael McCracken</dc:creator><description>&lt;p&gt;Like most students, I've been asked to review papers in my area (and a few that were pretty far outside it), and I always try to do a good job - this is definitely a golden-rule situation. If I don't take it seriously, I am absolutely convinced that karma will get me in the end, denying a crucial publication that could have pushed me over the edge to tenure.&lt;/p&gt;
&lt;p&gt;I've also been lucky enough to have the fascinating experience of helping out with the Program Committee of a major conference, something students don't usually get to do. It is the kind of experience that really gives you perspective, and it's harder to get upset about disappointing results since then. Important decisions often come down to the quality of the reviewers and practical constraints - for instance, you may have space for 12 papers in the area, and you might be looking at a paper has two 'strong accept' reviews and one 'weak', but is pretty good. It seems like a borderline paper that might get in, right? But there are probably 20 others that got three 'strong accept' reviews - this paper has no practical chance unless someone champions it and the 'weak accept' reviewer wasn't very convincing.&lt;/p&gt;
&lt;p&gt;The point of that little anecdote was that every review counts, even student reviews, and good reviews make the program committee's job a lot easier.&lt;/p&gt;
&lt;p&gt;Off the top of my head, here are a few rules of thumb to reviewing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read the whole thing. It's only fair.&lt;/li&gt;
&lt;li&gt;No matter what the questions on the review form say, always include a summary in your own words of the main point and contribution. This is really helpful to the author to put your other comments in perspective.&lt;/li&gt;
&lt;li&gt;Don't be a wimp. If you mean 'reject', say so. If you use 'weak accept', explain why.&lt;/li&gt;
&lt;li&gt;If there's space to add comments to the program committee, use it. Especially if you could be convinced to change your opinion of the paper. That can be useful if another reviewer had a very different opinion and the committee needs to reconcile them.&lt;/li&gt;
&lt;li&gt;You're reviewing for a specific venue - if the paper is good, but you can think of a better place for it, say that and name that place - maybe the authors won't have thought of it, and at least it'll soften the blow a bit if it doesn't make it.&lt;/li&gt;
&lt;li&gt;Take the time to scan the references - if they cite their own or similar work, check it out. This could be the only way you can answer the novelty question - how else will you know if they wrote the same paper six months ago and only added one result just to get to go on a nice trip?&lt;/li&gt;
&lt;li&gt;Be honest about your expertise - it can help with the decisions, and it's hard to tell if you were dismissive because the paper was crap or because you don't understand its importance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Does anyone else have a good tip for reviewing? Let me know in the comments.&lt;/p&gt;</description><category>grad-school</category><category>research</category><guid>http://michael-mccracken.net/2006/01/on-reviewing/</guid><pubDate>Fri, 20 Jan 2006 06:27:00 GMT</pubDate></item></channel></rss>